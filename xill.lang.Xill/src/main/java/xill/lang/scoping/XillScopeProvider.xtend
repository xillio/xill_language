/**
 * Copyright (C) 2015 Xillio (support@xillio.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * generated by Xtext
 */
package xill.lang.scoping

import java.io.File
import java.util.ArrayList
import java.util.List
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import xill.lang.xill.ForEachInstruction
import xill.lang.xill.FunctionCall
import xill.lang.xill.FunctionDeclaration
import xill.lang.xill.IncludeStatement
import xill.lang.xill.InstructionSet
import xill.lang.xill.Robot
import xill.lang.xill.UseStatement
import xill.lang.xill.Variable
import xill.lang.xill.VariableDeclaration
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import xill.lang.xill.ErrorInstruction

/**
 * This class contains custom scoping description.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
class XillScopeProvider extends AbstractDeclarativeScopeProvider {

    private static File projectFolder = new File(".");

    def static setProjectFolder(File folder) {
        projectFolder = folder
    }

    override getScope(EObject context, EReference reference) {
        switch(context) {
            FunctionCall: return getScope(context)
            UseStatement: return getScope(context)
            IncludeStatement: return Scopes.scopeFor(
        		context.resolveResource.contents
        			.filter(Robot)
        			.map(r|r.instructionSet.instructions)
        			.flatten()
        			.filter(FunctionDeclaration)
        			.filter(fn|!fn.isPrivate)
            )
            Variable: {
                var parentSet = context.parent;
                var node = NodeModelUtils.getNode(context)

                return getScope(parentSet, node.startLine);
            }
            default: super.getScope(context, reference)
        }
        super.getScope(context, reference)
    }

    def IScope getScope(FunctionCall functionCall) {
    	if(!functionCall.isQualified()) {
    		// This is a local or transitive function call
    		return Scopes.scopeFor(functionCall.robot.functionDeclarations(new ArrayList<Robot>(), functionCall, true));
    	} else {
    		// This is a function in a different library
    		var scope = functionCall.robot.includes;
    		
    		return Scopes.scopeFor(scope);
    	}
    }

    def Iterable<EObject> functionDeclarations(Robot robot, List<Robot> visited, FunctionCall functionCall, boolean isLocal) {
    	if(visited.contains(robot)) {
    		return #[];
    	}
        
        visited.add(robot);
    	
    	var result = new ArrayList<EObject>();
    	
        // Search local declarations
        result.addAll(
        	robot.instructionSet.instructions
    			.filter(FunctionDeclaration)
    			.filter(fn|isLocal || !fn.isPrivate())
    			.filter[fn|fn.parameters.size == functionCall.argumentBlock.parameters.size]
		);
    			
    			
        // And search included libraries
        result.addAll(
        	robot.includes
        	// Only search in unqualified includes
        	.filter[include|include.name == null]
        	// Resolve the robots
        	.map[resolveResource]
        	.filterNull()
        	.map[resource|resource.contents].flatten
        	.filter(Robot)
        	// Get all matching function declarations
        	.map[library|library.functionDeclarations(visited, functionCall, false)]
        	.flatten()
       );
        
       return result.filterNull();
    }

    def Resource resolveResource(IncludeStatement include) {
        var path = include.library.join(File.separator) + ".xill";
        var file = new File(projectFolder, path);
		var uri = URI.createFileURI(file.absolutePath);
		
        var set = include.eResource.resourceSet;

        for(Resource resource : set.resources) {
            if(resource.URI == uri) {
                return resource
            }
        }

        return null
    }

    //We only scope to the local use statements
    def IScope getScope(UseStatement statement) {
        var useStatements = new ArrayList<UseStatement>();
        useStatements.addAll(
                //Collect all use statements in this robot
                statement.robot.uses
        );
        return Scopes.scopeFor(useStatements);
    }

    //Get the scope of a Variable (Targets) that resides in this instructionSet
    def IScope getScope(InstructionSet set, int line) {
        if(set == null)
            return IScope.NULLSCOPE;

        //Find all variable declarations
        var targets = set.instructions.filter(VariableDeclaration).filter[dec | NodeModelUtils.getNode(dec).startLine < line].map[name].toList;

        var parent = set.eContainer.eContainer;

        //Special cases
        if(parent != null) {
            switch(parent) {
                ForEachInstruction: {
                    targets.add(parent.valueVar);

                    if(parent.keyVar != null) {
                        targets.add(parent.keyVar);
                    }
                }
                FunctionDeclaration: {
                    targets.addAll(parent.parameters);
                }
                ErrorInstruction: {
                    if(parent.cause != null) {
                        targets.addAll(parent.cause);
                    }
                }
            }
        }

        var parentSet = set.parent;
        var node = NodeModelUtils.getNode(set);
        return Scopes.scopeFor(targets, getScope(parentSet, node.startLine));
    }

    //Get the parent InstructionSet
    def InstructionSet getParent(EObject object) {
        if(object == null)
            return null;

        var parent = object.eContainer;

        switch(parent){
            InstructionSet: parent
            default: parent.parent
        }
    }

    def getRobot(EObject object) {
        var parent = object;
        while(!(parent instanceof Robot) && parent != null) {
            parent = parent.eContainer
        }

        return parent as Robot;
    }

}
