/*
 * generated by Xtext
 */
package xill.lang.scoping

import java.io.File
import java.util.ArrayList
import java.util.List
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import xill.lang.xill.ForEachInstruction
import xill.lang.xill.FunctionCall
import xill.lang.xill.FunctionDeclaration
import xill.lang.xill.IncludeStatement
import xill.lang.xill.InstructionSet
import xill.lang.xill.Robot
import xill.lang.xill.UseStatement
import xill.lang.xill.Variable
import xill.lang.xill.VariableDeclaration
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import xill.lang.xill.ErrorInstruction

/**
 * This class contains custom scoping description.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
class XillScopeProvider extends AbstractDeclarativeScopeProvider {

    private static File projectFolder = new File(".");

    def static setProjectFolder(File folder) {
        projectFolder = folder
    }

    override getScope(EObject context, EReference reference) {
        switch(context) {
            FunctionCall: return getScope(context)
            UseStatement: return getScope(context)
            Variable: {
                var parentSet = context.parent;
                var node = NodeModelUtils.getNode(context)

                return getScope(parentSet, node.startLine);
            }
            default: super.getScope(context, reference)
        }
        super.getScope(context, reference)
    }

    def IScope getScope(FunctionCall functionCall) {
        Scopes.scopeFor(functionCall.robot.functionDeclarations(new ArrayList<Resource>()));
    }

    def List<FunctionDeclaration> functionDeclarations(Robot robot, List<Resource> visited) {
        var declarations = new ArrayList<FunctionDeclaration>();

        //Add all local declarations
        declarations.addAll(robot.instructionSet.instructions.filter(FunctionDeclaration));


        //Add included libraries
        for(Resource lib : robot.includes.map[resolveResource]) {
            if(lib != null && !visited.contains(lib)) {
                visited.add(lib);
                declarations.addAll(lib.contents.filter(Robot).map[r | functionDeclarations(r,visited)].flatten.filter[fd | !fd.isPrivate()]);
            }
        }
        declarations;
    }

    def Resource resolveResource(IncludeStatement include) {
        var path = include.name.join(File.separator) + ".xill";
        var file = new File(projectFolder, path);

        var set = include.eResource.resourceSet;

        for(Resource resource : set.resources) {
            if(resource.URI == URI.createFileURI(file.absolutePath)) {
                return resource
            }
        }

        return null
    }

    //We only scope to the local use statements
    def IScope getScope(UseStatement statement) {
        var useStatements = new ArrayList<UseStatement>();
        useStatements.addAll(
                //Collect all use statements in this robot
                statement.robot.uses
        );
        return Scopes.scopeFor(useStatements);
    }

    //Get the scope of a Variable (Targets) that resides in this instructionSet
    def IScope getScope(InstructionSet set, int line) {
        if(set == null)
            return IScope.NULLSCOPE;

        //Find all variable declarations
        var targets = set.instructions.filter(VariableDeclaration).filter[dec | NodeModelUtils.getNode(dec).startLine < line].map[name].toList;

        var parent = set.eContainer.eContainer;

        //Special cases
        if(parent != null) {
            switch(parent) {
                ForEachInstruction: {
                    targets.add(parent.valueVar);

                    if(parent.keyVar != null) {
                        targets.add(parent.keyVar);
                    }
                }
                FunctionDeclaration: {
                    targets.addAll(parent.parameters);
                }
                ErrorInstruction: {
                    if(parent.cause != null) {
                        targets.addAll(parent.cause);
                    }
                }
            }
        }

        var parentSet = set.parent;
        var node = NodeModelUtils.getNode(set);
        return Scopes.scopeFor(targets, getScope(parentSet, node.startLine));
    }

    //Get the parent InstructionSet
    def InstructionSet getParent(EObject object) {
        if(object == null)
            return null;

        var parent = object.eContainer;

        switch(parent){
            InstructionSet: parent
            default: parent.parent
        }
    }

    def getRobot(EObject object) {
        var parent = object;
        while(!(parent instanceof Robot) && parent != null) {
            parent = parent.eContainer
        }

        return parent as Robot;
    }

}
